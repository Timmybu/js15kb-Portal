<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Portal Clone</title>
  <style>
    * { margin: 0; padding: 0; overflow: hidden; }
    body { width: 100vw; height: 100vh; background: #000; }
    canvas { display: block; width: 100%; height: 100%; }
    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      pointer-events: none;
    }
    #crosshair::before, #crosshair::after {
      content: '';
      position: absolute;
      background: rgba(255, 255, 255, 0.8);
    }
    #crosshair::before {
      left: 9px;
      top: 3px;
      width: 2px;
      height: 14px;
    }
    #crosshair::after {
      left: 3px;
      top: 9px;
      width: 14px;
      height: 2px;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="crosshair"></div>
  <script>
    'use strict';

    // === MATH UTILITIES ===
    const M = {
      // mat4 identity
      id: () => new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]),

      // mat4 multiply: out = a * b (column-major)
      mul: (a, b) => {
        const out = new Float32Array(16);
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            out[j*4+i] = a[0*4+i]*b[j*4+0] + a[1*4+i]*b[j*4+1] + a[2*4+i]*b[j*4+2] + a[3*4+i]*b[j*4+3];
          }
        }
        return out;
      },

      // mat4 perspective projection
      persp: (fov, aspect, near, far) => {
        const f = 1 / Math.tan(fov / 2);
        const nf = 1 / (near - far);
        return new Float32Array([
          f/aspect, 0, 0, 0,
          0, f, 0, 0,
          0, 0, (far+near)*nf, -1,
          0, 0, 2*far*near*nf, 0
        ]);
      },

      // mat4 lookAt view matrix
      lookAt: (eye, target, up) => {
        const z = V.norm(V.sub(eye, target));
        const x = V.norm(V.cross(up, z));
        const y = V.cross(z, x);
        return new Float32Array([
          x[0], y[0], z[0], 0,
          x[1], y[1], z[1], 0,
          x[2], y[2], z[2], 0,
          -V.dot(x,eye), -V.dot(y,eye), -V.dot(z,eye), 1
        ]);
      },

      // mat4 translate
      trans: (x, y, z) => new Float32Array([
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        x, y, z, 1
      ]),

      // mat4 rotate X
      rotX: (a) => {
        const c = Math.cos(a), s = Math.sin(a);
        return new Float32Array([
          1, 0, 0, 0,
          0, c, s, 0,
          0, -s, c, 0,
          0, 0, 0, 1
        ]);
      },

      // mat4 rotate Y
      rotY: (a) => {
        const c = Math.cos(a), s = Math.sin(a);
        return new Float32Array([
          c, 0, -s, 0,
          0, 1, 0, 0,
          s, 0, c, 0,
          0, 0, 0, 1
        ]);
      },

      // mat4 rotate Z
      rotZ: (a) => {
        const c = Math.cos(a), s = Math.sin(a);
        return new Float32Array([
          c, s, 0, 0,
          -s, c, 0, 0,
          0, 0, 1, 0,
          0, 0, 0, 1
        ]);
      }
    };

    // vec3 operations
    const V = {
      add: (a, b) => [a[0]+b[0], a[1]+b[1], a[2]+b[2]],
      sub: (a, b) => [a[0]-b[0], a[1]-b[1], a[2]-b[2]],
      scale: (v, s) => [v[0]*s, v[1]*s, v[2]*s],
      dot: (a, b) => a[0]*b[0] + a[1]*b[1] + a[2]*b[2],
      cross: (a, b) => [
        a[1]*b[2] - a[2]*b[1],
        a[2]*b[0] - a[0]*b[2],
        a[0]*b[1] - a[1]*b[0]
      ],
      len: (v) => Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]),
      norm: (v) => {
        const l = V.len(v);
        return l > 0 ? [v[0]/l, v[1]/l, v[2]/l] : [0,0,0];
      }
    };

    // === WEBGL SETUP ===
    const canvas = document.getElementById('c');
    const gl = canvas.getContext('webgl', { stencil: true });

    if (!gl) {
      alert('WebGL not supported');
      throw new Error('WebGL not supported');
    }

    // Resize canvas to match display size
    const resize = () => {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      gl.viewport(0, 0, canvas.width, canvas.height);
    };
    resize();
    window.addEventListener('resize', resize);

    // === SHADER COMPILATION ===
    const vertShader = `
      attribute vec3 aPosition;
      attribute vec3 aNormal;
      uniform mat4 uMVP;
      uniform mat4 uModel;
      varying vec3 vNormal;
      varying vec3 vPos;
      void main() {
        gl_Position = uMVP * vec4(aPosition, 1.0);
        vNormal = (uModel * vec4(aNormal, 0.0)).xyz;
        vPos = (uModel * vec4(aPosition, 1.0)).xyz;
      }
    `;

    const fragShader = `
      precision mediump float;
      uniform vec3 uColor;
      uniform float uPortalGlow;
      varying vec3 vNormal;
      varying vec3 vPos;
      void main() {
        vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
        vec3 normal = normalize(vNormal);
        float diff = max(dot(normal, lightDir), 0.0);
        float ambient = 0.45;
        vec3 color = uColor * (ambient + diff * 0.7);

        // Portal glow effect (not used yet)
        if (uPortalGlow > 0.0) {
          color += vec3(1.0, 0.5, 0.0) * uPortalGlow;
        }

        gl_FragColor = vec4(color, 1.0);
      }
    `;

    const compileShader = (src, type) => {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    };

    const vs = compileShader(vertShader, gl.VERTEX_SHADER);
    const fs = compileShader(fragShader, gl.FRAGMENT_SHADER);
    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);

    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      console.error('Program link error:', gl.getProgramInfoLog(prog));
    }

    gl.useProgram(prog);

    // Get attribute/uniform locations
    const aPos = gl.getAttribLocation(prog, 'aPosition');
    const aNorm = gl.getAttribLocation(prog, 'aNormal');
    const uMVP = gl.getUniformLocation(prog, 'uMVP');
    const uModel = gl.getUniformLocation(prog, 'uModel');
    const uColor = gl.getUniformLocation(prog, 'uColor');
    const uPortalGlow = gl.getUniformLocation(prog, 'uPortalGlow');

    // Enable depth test and backface culling
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);

    // === PROCEDURAL GEOMETRY ===
    const createBox = (w, h, d, invert = false) => {
      const hw = w/2, hh = h/2, hd = d/2;
      const s = invert ? -1 : 1;

      const positions = new Float32Array([
        // Front
        -hw, -hh,  hd,  hw, -hh,  hd,  hw,  hh,  hd, -hw,  hh,  hd,
        // Back
         hw, -hh, -hd, -hw, -hh, -hd, -hw,  hh, -hd,  hw,  hh, -hd,
        // Top
        -hw,  hh,  hd,  hw,  hh,  hd,  hw,  hh, -hd, -hw,  hh, -hd,
        // Bottom
        -hw, -hh, -hd,  hw, -hh, -hd,  hw, -hh,  hd, -hw, -hh,  hd,
        // Right
         hw, -hh,  hd,  hw, -hh, -hd,  hw,  hh, -hd,  hw,  hh,  hd,
        // Left
        -hw, -hh, -hd, -hw, -hh,  hd, -hw,  hh,  hd, -hw,  hh, -hd
      ]);

      const normals = new Float32Array([
        // Front
        0,0,s*1, 0,0,s*1, 0,0,s*1, 0,0,s*1,
        // Back
        0,0,s*-1, 0,0,s*-1, 0,0,s*-1, 0,0,s*-1,
        // Top
        0,s*1,0, 0,s*1,0, 0,s*1,0, 0,s*1,0,
        // Bottom
        0,s*-1,0, 0,s*-1,0, 0,s*-1,0, 0,s*-1,0,
        // Right
        s*1,0,0, s*1,0,0, s*1,0,0, s*1,0,0,
        // Left
        s*-1,0,0, s*-1,0,0, s*-1,0,0, s*-1,0,0
      ]);

      const indices = new Uint16Array([
        0,1,2, 0,2,3,       // Front
        4,5,6, 4,6,7,       // Back
        8,9,10, 8,10,11,    // Top
        12,13,14, 12,14,15, // Bottom
        16,17,18, 16,18,19, // Right
        20,21,22, 20,22,23  // Left
      ]);

      if (invert) {
        // Reverse winding order for inverted box
        for (let i = 0; i < indices.length; i += 3) {
          const tmp = indices[i];
          indices[i] = indices[i+2];
          indices[i+2] = tmp;
        }
      }

      return { positions, normals, indices };
    };

    const createPlane = (w, h, nx, ny, nz) => {
      const hw = w/2, hh = h/2;
      // Create a plane facing in the direction of the normal
      // For simplicity, assume plane is XY and normal is Z
      const positions = new Float32Array([
        -hw, -hh, 0,
         hw, -hh, 0,
         hw,  hh, 0,
        -hw,  hh, 0
      ]);

      const normals = new Float32Array([
        nx, ny, nz,
        nx, ny, nz,
        nx, ny, nz,
        nx, ny, nz
      ]);

      const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);

      return { positions, normals, indices };
    };

    // Build room geometry with individual faces based on flags bitmask
    // Flags: bit 0=front(+Z), 1=back(-Z), 2=top(+Y), 3=bottom(-Y), 4=right(+X), 5=left(-X)
    const buildRoomGeometry = (w, h, d, flags) => {
      const hw = w/2, hh = h/2, hd = d/2;
      const positions = [];
      const normals = [];
      const indices = [];
      let vertexOffset = 0;

      const addFace = (verts, norm) => {
        positions.push(...verts);
        normals.push(norm[0], norm[1], norm[2], norm[0], norm[1], norm[2], norm[0], norm[1], norm[2], norm[0], norm[1], norm[2]);
        // Two triangles (inverted winding for inward faces)
        indices.push(vertexOffset+2, vertexOffset+1, vertexOffset, vertexOffset+3, vertexOffset+2, vertexOffset);
        vertexOffset += 4;
      };

      // Front face (+Z) - bit 0
      if (flags & 0b000001) {
        addFace([
          -hw, -hh, hd,  hw, -hh, hd,  hw, hh, hd, -hw, hh, hd
        ], [0, 0, -1]);
      }

      // Back face (-Z) - bit 1
      if (flags & 0b000010) {
        addFace([
          hw, -hh, -hd, -hw, -hh, -hd, -hw, hh, -hd,  hw, hh, -hd
        ], [0, 0, 1]);
      }

      // Top face (+Y) - bit 2
      if (flags & 0b000100) {
        addFace([
          -hw, hh, hd,  hw, hh, hd,  hw, hh, -hd, -hw, hh, -hd
        ], [0, -1, 0]);
      }

      // Bottom face (-Y) - bit 3
      if (flags & 0b001000) {
        addFace([
          -hw, -hh, -hd,  hw, -hh, -hd,  hw, -hh, hd, -hw, -hh, hd
        ], [0, 1, 0]);
      }

      // Right face (+X) - bit 4
      if (flags & 0b010000) {
        addFace([
          hw, -hh, hd,  hw, -hh, -hd,  hw, hh, -hd,  hw, hh, hd
        ], [-1, 0, 0]);
      }

      // Left face (-X) - bit 5
      if (flags & 0b100000) {
        addFace([
          -hw, -hh, -hd, -hw, -hh, hd, -hw, hh, hd, -hw, hh, -hd
        ], [1, 0, 0]);
      }

      return {
        positions: new Float32Array(positions),
        normals: new Float32Array(normals),
        indices: new Uint16Array(indices)
      };
    };

    // === GEOMETRY BUFFER MANAGEMENT ===
    const createBuffers = (geom) => {
      const posBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, geom.positions, gl.STATIC_DRAW);

      const normBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, geom.normals, gl.STATIC_DRAW);

      const idxBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geom.indices, gl.STATIC_DRAW);

      return {
        pos: posBuffer,
        norm: normBuffer,
        idx: idxBuffer,
        count: geom.indices.length
      };
    };

    // === LEVEL BUILDING ===
    const LEVEL_1 = [
      // [x, y, z, w, h, d, color, flags]
      // Flags: bit 0=front(+Z), 1=back(-Z), 2=top(+Y), 3=bottom(-Y), 4=right(+X), 5=left(-X)
      [0, 0, 0, 10, 4, 10, [0.9, 0.9, 0.9], 0b101111],      // right wall open (bit 4 = 0)
      [9, 0, 0, 8, 4, 12, [0.85, 0.85, 0.88], 0b011111],    // left wall open (bit 5 = 0)
      [-8, 0, 0, 6, 4, 8, [0.88, 0.88, 0.9], 0b101111]      // right wall open (bit 4 = 0)
    ];

    const levelGeometry = [];
    const levelFaces = [];
    const portals = { blue: null, orange: null };
    let portalMesh = null;

    const buildLevel = (data) => {
      for (let roomIdx = 0; roomIdx < data.length; roomIdx++) {
        const [x, y, z, w, h, d, color, flags] = data[roomIdx];
        const hw = w/2, hh = h/2, hd = d/2;

        // Build room with individual faces based on flags
        const geom = buildRoomGeometry(w, h, d, flags);
        const buffers = createBuffers(geom);

        // Offset Y by +h/2 so floor sits at specified Y coordinate
        const roomPos = [x, y + h/2, z];
        levelGeometry.push({
          buffers,
          pos: roomPos,
          color,
          glow: 0
        });

        // Track individual faces for raycasting
        // Face format: [faceType, normal, planeAxis, planeValue, axis1Idx, axis2Idx, bounds, eligible]
        const faceData = [
          [0, [0,0,-1], 2, z+hd, 0, 1, [[x-hw,x+hw], [y,y+h]], (flags&1)>0],  // Front +Z
          [1, [0,0,1],  2, z-hd, 0, 1, [[x-hw,x+hw], [y,y+h]], (flags&2)>0],  // Back -Z
          [2, [0,-1,0], 1, y+h,  0, 2, [[x-hw,x+hw], [z-hd,z+hd]], false],    // Top +Y (ceiling)
          [3, [0,1,0],  1, y,    0, 2, [[x-hw,x+hw], [z-hd,z+hd]], (flags&8)>0], // Bottom -Y (floor)
          [4, [-1,0,0], 0, x+hw, 1, 2, [[y,y+h], [z-hd,z+hd]], (flags&16)>0], // Right +X
          [5, [1,0,0],  0, x-hw, 1, 2, [[y,y+h], [z-hd,z+hd]], (flags&32)>0]  // Left -X
        ];

        for (const [faceType, normal, planeAxis, planeValue, axis1Idx, axis2Idx, bounds, eligible] of faceData) {
          if (eligible) {
            // Compute face center in world space
            const centerCoords = [x, y + h/2, z];
            centerCoords[planeAxis] = planeValue;

            levelFaces.push({
              roomIdx,
              faceType,
              center: centerCoords,
              normal,
              planeAxis,
              planeValue,
              axis1Idx,
              axis2Idx,
              bounds: { axis1: bounds[0], axis2: bounds[1] },
              eligible: true
            });
          }
        }
      }
    };

    buildLevel(LEVEL_1);
    console.log('Level faces tracked:', levelFaces.length);

    // === RAYCASTING ===
    const raycast = (origin, dir) => {
      let closestHit = null;
      let minT = 50; // Max range

      for (let i = 0; i < levelFaces.length; i++) {
        const face = levelFaces[i];
        if (!face.eligible) continue;

        // Ray-plane intersection for axis-aligned plane
        const denom = dir[face.planeAxis];
        if (Math.abs(denom) < 0.0001) continue; // Parallel to plane

        const t = (face.planeValue - origin[face.planeAxis]) / denom;
        if (t < 0.01 || t >= minT) continue; // Behind camera or too far

        // Compute hit point
        const hit = [
          origin[0] + dir[0] * t,
          origin[1] + dir[1] * t,
          origin[2] + dir[2] * t
        ];

        // Check bounds on the two tangent axes
        const u = hit[face.axis1Idx];
        const v = hit[face.axis2Idx];

        if (u >= face.bounds.axis1[0] && u <= face.bounds.axis1[1] &&
            v >= face.bounds.axis2[0] && v <= face.bounds.axis2[1]) {
          minT = t;
          closestHit = {
            point: hit,
            normal: face.normal,
            faceIdx: i,
            t: t
          };
        }
      }

      return closestHit;
    };

    // === PORTAL GEOMETRY ===
    const createPortalMesh = () => {
      const segments = 16;
      const w = 1.2; // Portal width
      const h = 2.0; // Portal height

      const positions = [0, 0, 0]; // Center vertex
      const normals = [];
      const indices = [];

      // Fill normals for center
      for (let i = 0; i <= segments + 1; i++) {
        normals.push(0, 0, 1);
      }

      // Generate oval ring
      for (let i = 0; i <= segments; i++) {
        const angle = (i / segments) * Math.PI * 2;
        positions.push(
          Math.cos(angle) * w/2,
          Math.sin(angle) * h/2,
          0
        );
      }

      // Triangle fan indices
      for (let i = 1; i <= segments; i++) {
        indices.push(0, i, i + 1);
      }

      return createBuffers({
        positions: new Float32Array(positions),
        normals: new Float32Array(normals),
        indices: new Uint16Array(indices)
      });
    };

    // Initialize portal mesh
    portalMesh = createPortalMesh();

    // === CAMERA & CONTROLS ===
    const cam = {
      pos: [0, 1, 5],
      pitch: 0,  // radians
      yaw: 0,    // radians
      fov: 70 * Math.PI / 180
    };

    const keys = {};
    const mouse = { dx: 0, dy: 0 };
    let pointerLocked = false;

    // Keyboard input
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);

    // Pointer lock
    canvas.addEventListener('click', () => {
      if (!pointerLocked) {
        canvas.requestPointerLock();
      }
    });

    document.addEventListener('pointerlockchange', () => {
      pointerLocked = document.pointerLockElement === canvas;
    });

    // Mouse movement
    document.addEventListener('mousemove', e => {
      if (pointerLocked) {
        mouse.dx = e.movementX;
        mouse.dy = e.movementY;
      }
    });

    // Mouse buttons - Portal placement
    canvas.addEventListener('mousedown', e => {
      if (pointerLocked) {
        // Compute camera direction
        const camDir = [
          Math.cos(cam.pitch) * -Math.sin(cam.yaw),
          Math.sin(cam.pitch),
          Math.cos(cam.pitch) * -Math.cos(cam.yaw)
        ];

        // Raycast to find wall hit
        const hit = raycast(cam.pos, camDir);

        if (hit) {
          const face = levelFaces[hit.faceIdx];

          // Compute portal frame (up and right vectors)
          let up, right;
          if (Math.abs(face.normal[1]) < 0.9) {
            // Wall portal (normal mostly horizontal)
            up = [0, 1, 0];
            right = V.norm(V.cross(up, face.normal));
          } else {
            // Floor portal (normal is [0,±1,0])
            // Orient up based on camera forward projection
            const camFwd = [
              -Math.sin(cam.yaw),
              0,
              -Math.cos(cam.yaw)
            ];
            up = V.norm(camFwd);
            right = V.norm(V.cross(up, face.normal));
            up = V.cross(face.normal, right); // Recompute for orthogonality
          }

          // Offset position slightly to avoid z-fighting
          const pos = V.add(hit.point, V.scale(face.normal, 0.01));

          const portal = {
            pos,
            normal: face.normal,
            up,
            right,
            faceIdx: hit.faceIdx,
            active: true
          };

          if (e.button === 0) {
            portals.blue = portal;
            console.log('Blue portal placed at', pos);
          } else if (e.button === 2) {
            portals.orange = portal;
            console.log('Orange portal placed at', pos);
          }
        }
      }
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // === PHYSICS ===
    const player = {
      w: 0.6,
      h: 1.8,
      d: 0.6,
      vel: [0, 0, 0],
      grounded: false
    };

    const GRAVITY = 9.8;
    const MOVE_SPEED = 5;
    const JUMP_VEL = 5;

    const updatePhysics = (dt) => {
      // Apply gravity
      if (!player.grounded) {
        player.vel[1] -= GRAVITY * dt;
      }

      // Update position
      cam.pos[0] += player.vel[0] * dt;
      cam.pos[1] += player.vel[1] * dt;
      cam.pos[2] += player.vel[2] * dt;

      // Ground collision (simple floor at y=0)
      const groundY = player.h / 2;
      if (cam.pos[1] < groundY) {
        cam.pos[1] = groundY;
        player.vel[1] = 0;
        player.grounded = true;
      } else if (cam.pos[1] > groundY + 0.1) {
        player.grounded = false;
      }

      // Simple wall collision - keep player within bounds
      const bounds = 20;
      if (Math.abs(cam.pos[0]) > bounds) {
        cam.pos[0] = Math.sign(cam.pos[0]) * bounds;
        player.vel[0] = 0;
      }
      if (Math.abs(cam.pos[2]) > bounds) {
        cam.pos[2] = Math.sign(cam.pos[2]) * bounds;
        player.vel[2] = 0;
      }
    };

    // === INPUT HANDLING ===
    const handleInput = (dt) => {
      // Mouse look
      const sensitivity = 0.002;
      cam.yaw -= mouse.dx * sensitivity;
      cam.pitch -= mouse.dy * sensitivity;

      // Clamp pitch
      const maxPitch = 89 * Math.PI / 180;
      cam.pitch = Math.max(-maxPitch, Math.min(maxPitch, cam.pitch));

      mouse.dx = 0;
      mouse.dy = 0;

      // Movement
      const forward = [
        -Math.sin(cam.yaw),
        0,
        -Math.cos(cam.yaw)
      ];
      const right = [
        Math.cos(cam.yaw),
        0,
        -Math.sin(cam.yaw)
      ];

      let moveX = 0, moveZ = 0;

      if (keys['KeyW']) {
        moveX += forward[0];
        moveZ += forward[2];
      }
      if (keys['KeyS']) {
        moveX -= forward[0];
        moveZ -= forward[2];
      }
      if (keys['KeyD']) {
        moveX += right[0];
        moveZ += right[2];
      }
      if (keys['KeyA']) {
        moveX -= right[0];
        moveZ -= right[2];
      }

      // Normalize movement
      const moveLen = Math.sqrt(moveX*moveX + moveZ*moveZ);
      if (moveLen > 0) {
        moveX /= moveLen;
        moveZ /= moveLen;
      }

      player.vel[0] = moveX * MOVE_SPEED;
      player.vel[2] = moveZ * MOVE_SPEED;

      // Jump
      if (keys['Space'] && player.grounded) {
        player.vel[1] = JUMP_VEL;
        player.grounded = false;
      }
    };

    // === PORTAL UPDATE (STUB) ===
    const updatePortals = () => {
      // Placeholder for portal logic
    };

    // === HELPER FUNCTIONS ===
    const getCamDir = () => [
      Math.cos(cam.pitch) * -Math.sin(cam.yaw),
      Math.sin(cam.pitch),
      Math.cos(cam.pitch) * -Math.cos(cam.yaw)
    ];

    const getViewMatrix = () => {
      const camDir = getCamDir();
      const target = V.add(cam.pos, camDir);
      return M.lookAt(cam.pos, target, [0, 1, 0]);
    };

    const drawScene = (proj, view) => {
      const vp = M.mul(proj, view);

      for (const obj of levelGeometry) {
        const model = M.trans(obj.pos[0], obj.pos[1], obj.pos[2]);
        const mvp = M.mul(vp, model);

        gl.bindBuffer(gl.ARRAY_BUFFER, obj.buffers.pos);
        gl.enableVertexAttribArray(aPos);
        gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, obj.buffers.norm);
        gl.enableVertexAttribArray(aNorm);
        gl.vertexAttribPointer(aNorm, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.buffers.idx);

        gl.uniformMatrix4fv(uMVP, false, mvp);
        gl.uniformMatrix4fv(uModel, false, model);
        gl.uniform3fv(uColor, obj.color);
        gl.uniform1f(uPortalGlow, obj.glow);

        gl.drawElements(gl.TRIANGLES, obj.buffers.count, gl.UNSIGNED_SHORT, 0);
      }
    };

    // === PORTAL RENDERING ===
    const computePortalView = (portalA, portalB, camPos, camDir) => {
      // Transform camera from portal A's frame to portal B's frame
      const offset = V.sub(camPos, portalA.pos);
      const localX = V.dot(offset, portalA.right);
      const localY = V.dot(offset, portalA.up);
      const localZ = V.dot(offset, portalA.normal);

      // Apply to portal B with 180° rotation (flip X and Z)
      const virtualPos = V.add(portalB.pos,
        V.add(V.scale(portalB.right, -localX),
        V.add(V.scale(portalB.up, localY),
              V.scale(portalB.normal, -localZ)))
      );

      // Transform camera direction
      const dirLocalX = V.dot(camDir, portalA.right);
      const dirLocalY = V.dot(camDir, portalA.up);
      const dirLocalZ = V.dot(camDir, portalA.normal);

      const virtualDir = V.add(
        V.scale(portalB.right, -dirLocalX),
        V.add(V.scale(portalB.up, dirLocalY),
              V.scale(portalB.normal, -dirLocalZ))
      );

      const virtualTarget = V.add(virtualPos, virtualDir);
      return M.lookAt(virtualPos, virtualTarget, [0, 1, 0]);
    };

    const drawPortalQuad = (portal, proj, view) => {
      // Build model matrix from portal basis vectors
      const model = new Float32Array([
        portal.right[0], portal.right[1], portal.right[2], 0,
        portal.up[0], portal.up[1], portal.up[2], 0,
        portal.normal[0], portal.normal[1], portal.normal[2], 0,
        portal.pos[0], portal.pos[1], portal.pos[2], 1
      ]);

      const mvp = M.mul(M.mul(proj, view), model);

      gl.bindBuffer(gl.ARRAY_BUFFER, portalMesh.pos);
      gl.enableVertexAttribArray(aPos);
      gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ARRAY_BUFFER, portalMesh.norm);
      gl.enableVertexAttribArray(aNorm);
      gl.vertexAttribPointer(aNorm, 3, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, portalMesh.idx);

      gl.uniformMatrix4fv(uMVP, false, mvp);
      gl.uniformMatrix4fv(uModel, false, model);
      gl.uniform3f(uColor, 1, 1, 1);
      gl.uniform1f(uPortalGlow, 0);

      gl.drawElements(gl.TRIANGLES, portalMesh.count, gl.UNSIGNED_SHORT, 0);
    };

    const drawPortalOval = (portal, proj, view, color) => {
      gl.disable(gl.DEPTH_TEST);

      const model = new Float32Array([
        portal.right[0], portal.right[1], portal.right[2], 0,
        portal.up[0], portal.up[1], portal.up[2], 0,
        portal.normal[0], portal.normal[1], portal.normal[2], 0,
        portal.pos[0], portal.pos[1], portal.pos[2], 1
      ]);

      const mvp = M.mul(M.mul(proj, view), model);

      gl.bindBuffer(gl.ARRAY_BUFFER, portalMesh.pos);
      gl.enableVertexAttribArray(aPos);
      gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ARRAY_BUFFER, portalMesh.norm);
      gl.enableVertexAttribArray(aNorm);
      gl.vertexAttribPointer(aNorm, 3, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, portalMesh.idx);

      gl.uniformMatrix4fv(uMVP, false, mvp);
      gl.uniformMatrix4fv(uModel, false, model);
      gl.uniform3fv(uColor, color);
      gl.uniform1f(uPortalGlow, 0.3);

      gl.drawElements(gl.TRIANGLES, portalMesh.count, gl.UNSIGNED_SHORT, 0);

      gl.enable(gl.DEPTH_TEST);
    };

    const renderPortal = (portalA, portalB, proj, mainView, stencilVal) => {
      // Step 1: STENCIL PASS - Mark portal shape
      gl.enable(gl.STENCIL_TEST);
      gl.stencilFunc(gl.ALWAYS, stencilVal, 0xFF);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
      gl.colorMask(false, false, false, false);
      gl.depthMask(false);

      drawPortalQuad(portalA, proj, mainView);

      // Step 2: SCENE PASS - Render through portal
      gl.colorMask(true, true, true, true);
      gl.depthMask(true);
      gl.stencilFunc(gl.EQUAL, stencilVal, 0xFF);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
      gl.clear(gl.DEPTH_BUFFER_BIT);

      const virtualView = computePortalView(portalA, portalB, cam.pos, getCamDir());
      drawScene(proj, virtualView);

      // Step 3: DEPTH FILL - Write portal depth
      gl.colorMask(false, false, false, false);
      gl.depthMask(true);
      drawPortalQuad(portalA, proj, mainView);

      // Reset
      gl.colorMask(true, true, true, true);
      gl.stencilFunc(gl.ALWAYS, 0, 0xFF);
    };

    // === RENDERING ===
    const render = () => {
      // Clear all buffers
      gl.clearColor(0.2, 0.2, 0.2, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

      const aspect = canvas.width / canvas.height;
      const proj = M.persp(cam.fov, aspect, 0.1, 100);
      const view = getViewMatrix();

      // Phase 1: Render portals (if both active)
      if (portals.blue && portals.blue.active &&
          portals.orange && portals.orange.active) {
        renderPortal(portals.blue, portals.orange, proj, view, 1);
        renderPortal(portals.orange, portals.blue, proj, view, 2);
      }

      // Phase 2: Render main scene
      gl.disable(gl.STENCIL_TEST);
      drawScene(proj, view);

      // Phase 3: Draw portal ovals
      if (portals.blue && portals.blue.active) {
        drawPortalOval(portals.blue, proj, view, [0.3, 0.6, 1.0]);
      }
      if (portals.orange && portals.orange.active) {
        drawPortalOval(portals.orange, proj, view, [1.0, 0.5, 0.1]);
      }
    };

    // === GAME LOOP ===
    let lastT = 0;
    const frame = (t) => {
      const dt = Math.min((t - lastT) / 1000, 0.1); // Cap dt to 100ms
      lastT = t;

      handleInput(dt);
      updatePhysics(dt);
      updatePortals();
      render();

      requestAnimationFrame(frame);
    };

    requestAnimationFrame(frame);
  </script>
</body>
</html>
